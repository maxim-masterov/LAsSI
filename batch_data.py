import json
import os
# from io import print_err_info
from version import *
from io import *


class BatchFileData:
    modules = []
    script_base_name = None
    exec_name = None
    exec_options = None
    envars = None
    nodes = 1
    ntasks = 1
    cpus = 1
    partition = 'thin'
    time = 1
    launcher = 'srun'

    def read_config(self, thread_range, config_file_name):
        """
        Read JSON config file
        :param thread_range: Range of threads count
        :param config_file_name: Name of the config file
        """
        f = open(config_file_name)
        data = json.load(f)
        
        self.modules = data['modules']
        self.script_base_name = data['batch_data']['script_base_name']
        self.exec_name = data['batch_data']['executable_name']
        self.exec_options = data['batch_data']['executable_options']
        self.launcher = data['batch_data']['launcher']
        self.nodes = data['batch_data']['nodes']
        self.ntasks = data['batch_data']['ntasks']
        self.time = data['batch_data']['time']

        thread_range = range(
            data['test_setup']['thread_range'][0],
            data['test_setup']['thread_range'][1]
        )
        f.close()


    def dump_text_to_file(selft, filename, text):
        """
        Dump text to file
        :param filename: File name
        :param text: Text to write
        :return: None
        """
        file = open(filename, 'w')
        file.write(text)
        file.close()


    def generate_batch_file(self, src, name_postfix=''):
        """
        Generate batch script from the provided input
        :return: Name of the batch file
        """
        file_shebang = '#!/bin/bash'
        file_version = '#\n' \
                    '# This batch script was autogenerated by CowBerry v{0}\n' \
                    '#\n'.format(VERSION)
        file_header = '#SBATCH -N {0}\n' \
                      '#SBATCH -n {1}\n' \
                      '#SBATCH -c {2}\n' \
                      '#SBATCH -p {3}\n' \
                      '#SBATCH -t {4}\n'.format(self.nodes, self.ntasks, 
                                                self.cpus, self.partition,
                                                self.time)

        # if folder doesn't exist it won't be created :(
        if name_postfix != '':
            file_header += '#SBATCH -o ./' + name_postfix + '/output.%j.out\n'

        file_envars = ''
        if not self.envars:
            file_envars = '# main body is empty\n'
        else:
            for envar, value in self.envars:
                file_envars += 'export ' + envar + '=' + str(value) + '\n'

        # Compile the code
        file_comp = ''
        if src.should_recompile():
            file_comp = src.get_compile_cmd() + '\n\n'

        # 1) check if self.exec_name can be found in the current folder
        # 2) copy self.exec_name to the TMPDIR
        file_body  = 'echo "JOBID: ${SLURM_JOB_ID}"\n'
        file_body += 'cp ' + self.exec_name + ' ${TMPDIR}\n'
        file_body += 'WRKDIR=${PWD}\n'
        file_body += 'mkdir ${WRKDIR}/' + name_postfix + '\n'
        file_body += 'cd ${TMPDIR}\n'

        file_module = 'module purge\n'
        for module in self.modules:
            file_module += 'module load ' + module + '\n'

        file_cmd = self.launcher + ' ' + self.exec_name + ' ' + self.exec_options + '\n'

        file_footer = ''
        if name_postfix != '':
            file_footer  = 'cp -r ${TMPDIR} ${WRKDIR}/' + name_postfix + '\n'
            # file_footer += 'cp slurm-${SLURM_JOB_ID}.out ' + name_postfix

        full_text = file_shebang + '\n' \
                    + file_version + '\n' \
                    + file_header + '\n' \
                    + file_module + '\n' \
                    + file_envars + '\n' \
                    + file_comp + '\n' \
                    + file_body + '\n' \
                    + file_cmd + '\n' \
                    + file_footer

        print('----------------------------------------')
        print(full_text)
        print('----------------------------------------')

        batch_file_name = self.script_base_name + name_postfix + '.sh'
        self.dump_text_to_file(batch_file_name, full_text)

        return batch_file_name


    def generate_interactive_cmd(self, src, name_postfix=''):
        """
        Generate interactive SLURM command
        :return: Name of the batch file
        """
        cmd_header = '-N {0} ' \
                     '-n {1} ' \
                     '-c {2} ' \
                     '-p {3} ' \
                     '-t {4} '.format(self.nodes, self.ntasks, 
                                      self.cpus, self.partition,
                                      self.time)

        if name_postfix != '':
            cmd_header += '-o ./' + name_postfix + '/output.%j.out '

        file_shebang = '#!/bin/bash'
        file_version = '#\n' \
                    '# This script was autogenerated by CowBerry v{0}\n' \
                    '#\n'.format(VERSION)

        file_envars = ''
        if not self.envars:
            file_envars = '# main body is empty\n'
        else:
            for envar, value in self.envars:
                file_envars += 'export ' + envar + '=' + str(value) + '\n'

        # Compile the code
        file_comp = ''
        if src.should_recompile():
            file_comp = src.get_compile_cmd() + '\n'

        # 1) check if self.exec_name can be found in the current folder
        # 2) copy self.exec_name to the TMPDIR
        file_body  = 'echo "JOBID: ${SLURM_JOB_ID}"\n'
        file_body += 'cp ' + self.exec_name + ' ${TMPDIR}\n'
        file_body += 'WRKDIR=${PWD}\n'
        file_body += 'mkdir ${WRKDIR}/' + name_postfix + '\n'
        file_body += 'cd ${TMPDIR}\n'

        file_module = 'module purge\n'
        for module in self.modules:
            file_module += 'module load ' + module + '\n'

        file_cmd = self.launcher + ' ' + self.exec_name + ' ' + self.exec_options + '\n'

        file_footer = ''
        if name_postfix != '':
            file_footer  = 'cp -r ${TMPDIR} ${WRKDIR}/' + name_postfix + '\n'
            # file_footer += 'cp slurm-${SLURM_JOB_ID}.out ' + name_postfix

        full_text = file_shebang + '\n' \
                    + file_version + '\n' \
                    + file_module + '\n' \
                    + file_envars + '\n' \
                    + file_comp + '\n' \
                    + file_body + '\n' \
                    + file_cmd + '\n' \
                    + file_footer

        # print('----------------------------------------')
        # print(full_text)
        # print('----------------------------------------')

        bash_file_name = self.script_base_name + name_postfix + '.sh'
        self.dump_text_to_file(bash_file_name, full_text)

        complete_cmd_call = 'srun ' + cmd_header

        return complete_cmd_call, bash_file_name


    def submit_batch_script(self, batch_filename):
        if batch_filename == '':
            print_err_info('Batch file name is empty')
            exit(-1)
        os.system('sbatch ' + batch_filename)


    def submit_interactively(self, cmd, bash_file_name):
        if cmd == '':
            print_err_info('Command for the interactive submission is empty')
            exit(-1)
        if bash_file_name == '':
            print_err_info('Bash file name is empty')
            exit(-1)

        os.system('chmod +x ' + bash_file_name)
        print(cmd + ' ' + bash_file_name)
        # os.system(cmd + ' ' + bash_file_name)



# - create tmpdir and report its full path
# - copy sources to tmpdir
# - build source in tmpdir
# - write job script in tmpdir
# - submit jobscript(s) in tmpdir
# - wait untill all jobscripts are finished (async. calls? subprocesses?)