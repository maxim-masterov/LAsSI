import json
import os
import sys
import re
import time

from version import *
import io_manager


class BatchFileData:
    _modules = []
    _script_base_name = None
    _exec_options = None
    _envars = None
    _nodes = 1
    _ntasks = 1
    _cpus = 1
    _partition = 'thin'
    _time = 1
    _launcher = 'srun'
    _bash_file_ext = 'sh'
    _log_name = 'output.log'

    def get_modules(self):
        return self._modules

    def get_script_base_name(self):
        return self._script_base_name

    def get_exec_options(self):
        return self._exec_options

    def get_envars(self):
        return self._envars

    def get_nodes(self):
        return self._nodes

    def get_ntasks(self):
        return self._ntasks

    def get_cpus(self):
        return self._cpus

    def get_partition(self):
        return self._partition

    def get_time(self):
        return self._time

    def get_launcher(self):
        return self._launcher

    def get_bash_file_ext(self):
        return self._bash_file_ext

    def get_log_name(self):
        return self._log_name

    def read_config(self, thread_range, config_file_name):
        """
        Read JSON config file
        :param thread_range: Range of threads count
        :param config_file_name: Name of the config file
        """
        f = open(config_file_name)
        data = json.load(f)
        
        self._modules = data['modules']
        self._script_base_name = data['batch_data']['script_base_name']
        self._partition = data['batch_data']['partition']
        self._exec_options = data['batch_data']['executable_options']
        self._launcher = data['batch_data']['launcher']
        self._nodes = data['batch_data']['nodes']
        self._ntasks = data['batch_data']['ntasks']
        self._time = data['batch_data']['time']

        thread_range = range(
            data['test_setup']['thread_range'][0],
            data['test_setup']['thread_range'][1]
        )
        f.close()

    def dump_text_to_file(selft, filename, text):
        """
        Dump text to file
        :param filename: File name
        :param text: Text to write
        :return: None
        """
        file = open(filename, 'w')
        file.write(text)
        file.close()

    def _assemble_file(self, src, name_postfix='', compiler_flag_id=0):
        """
        Generate batch script from the provided input
        :param src: Object of ScrData
        :param name_postfix: Postfix that represents the test case
        :return: Full text of the job script and a header string that
                 can be used to parse and modify the header of the file
        """
        file_shebang = '#!/bin/bash'
        file_version = '#\n' \
                    '# This batch script was autogenerated by CowBerry v{0}\n' \
                    '#\n'.format(VERSION)
        file_header = '###-==[HEADER]==-###'

        # if folder doesn't exist it won't be created :(
        if name_postfix != '':
            file_header += '#SBATCH -o ./' + name_postfix + '/output.%j.out\n'

        file_envars = ''
        if not self.get_envars():
            file_envars = '# no environment variables set\n'
        else:
            for envar, value in self.get_envars():
                file_envars += 'export ' + envar + '=' + str(value) + '\n'

        # Compile the code
        file_comp = ''
        if src.get_recompile_flag():
            file_comp = src.get_compile_cmd(compiler_flag_id) + '\n'
        else:
            file_comp = '# do not rebuild sources \n'

        # TODO;
        # 1) check if self._exec_name can be found in the current folder
        # 2) copy self._exec_name to the TMPDIR
        file_body  = 'echo "JOBID: ${SLURM_JOB_ID}"\n'
        file_body += 'cp ' + src.get_exec_name() + ' ${TMPDIR}\n'
        file_body += 'WRKDIR=${PWD}\n'
        results_dir = '${WRKDIR}/results' + name_postfix
        if name_postfix != '':
            file_body += 'mkdir ' + results_dir + '\n'
        file_body += 'cd ${TMPDIR}\n'

        file_module = 'module purge\n'
        for module in self.get_modules():
            file_module += 'module load ' + module + '\n'

        file_cmd = self.get_launcher() + ' ' + src.get_exec_name() + ' ' + self.get_exec_options() + '\n'

        file_footer = ''
        if name_postfix != '':
            file_footer  = 'cp -r ${TMPDIR} ' + results_dir + '\n'
            # file_footer += 'cp slurm-${SLURM_JOB_ID}.out ' + name_postfix

        full_text = file_shebang + '\n' \
                    + file_version + '\n' \
                    + file_header + '\n' \
                    + file_module + '\n' \
                    + file_envars + '\n' \
                    + file_comp + '\n' \
                    + file_body + '\n' \
                    + file_cmd + '\n' \
                    + file_footer

        return full_text, file_header

    def _assemble_bash_file_name(self, wrk_dir, name_postfix):
        return wrk_dir + '/' + self.get_script_base_name() + name_postfix + '.' + self.get_bash_file_ext()

    def generate_batch_file(self, src, wrk_dir='.', name_postfix='', compiler_flag_id=0):
        """
        Generate batch script from the provided input
        :param src: Object of ScrData
        :param name_postfix: Postfix that represents the test case
        :return: Name of the batch file
        """
        file_header = '#SBATCH -N {0}\n' \
                      '#SBATCH -n {1}\n' \
                      '#SBATCH -c {2}\n' \
                      '#SBATCH -p {3}\n' \
                      '#SBATCH -t {4}\n'.format(self.get_nodes(), self.get_ntasks(), 
                                                self.get_cpus(), self.get_partition(),
                                                self.get_time())

        full_text, header_str = self._assemble_file(src, name_postfix, compiler_flag_id)

        full_text = full_text.replace(header_str, file_header)

        # io_manager.print_dbg_info('Generated batch script:')
        # io_manager.print_info('----------------------------------------', '')
        # io_manager.print_info(full_text, '')
        # io_manager.print_info('----------------------------------------', '')

        batch_file_name = self._assemble_bash_file_name(wrk_dir, name_postfix)
        self.dump_text_to_file(batch_file_name, full_text)

        return batch_file_name

    def generate_interactive_cmd(self, src, wrk_dir='.', name_postfix=''):
        """
        Generate interactive SLURM command
        :param src: Object of SrcData
        :return: Name of the batch file
        """
        cmd_header = '-N {0} ' \
                     '-n {1} ' \
                     '-c {2} ' \
                     '-p {3} ' \
                     '-t {4} '.format(self.get_nodes(), self.get_ntasks(),
                                      self.get_cpus(), self.get_partition(),
                                      self.get_time())

        if name_postfix != '':
            cmd_header += '-o ./' + name_postfix + '/output.%j.out '

        full_text, header_str = self._assemble_file(src, name_postfix)

        # io_manager.print_dbg_info('Generated batch script:')
        # io_manager.print_info('----------------------------------------', '')
        # io_manager.print_info(full_text, '')
        # io_manager.print_info('----------------------------------------', '')

        bash_file_name = self._assemble_bash_file_name(wrk_dir, name_postfix)
        self.dump_text_to_file(bash_file_name, full_text)

        complete_cmd_call = 'srun ' + cmd_header

        io_manager.print_dbg_info('Complete command call: ' + complete_cmd_call)
        io_manager.print_dbg_info('Bash file name: ' + bash_file_name)

        return complete_cmd_call, bash_file_name

    def submit_batch_script(self, batch_file_name):
        if batch_file_name == '':
            io_manager.print_err_info('Batch file name is empty')
            sys.exit(1)
        
        # clean up the tmp file
        if os.path.isfile(self.get_log_name()):
            os.remove(self.get_log_name())

        io_manager.print_dbg_info('Submit batch script: ' + batch_file_name)

        os.system('sbatch --wait ' + batch_file_name + ' &> ' + self.get_log_name())

        # Report job ID and exit state
        job_id = self._extract_job_id(self.get_log_name())
        slurm_file_name = 'slurm-' + job_id + '.out'
        # print('slurm_file_name: ' + slurm_file_name)
        state = self._extract_job_state(slurm_file_name)
        if job_id == None:
            io_manager.print_err_info('Could not parse the job ID. Returned value is None')
        elif state == None:
            io_manager.print_err_info('Could not parse the job state. Returned value is None')
        else:
            io_manager.print_dbg_info('Job #' + str(job_id) +' is finished with state: ' + state)

        return job_id

    def submit_interactively(self, cmd, bash_file_name):
        if cmd == '':
            io_manager.print_err_info('Command for the interactive submission is empty')
            sys.exit(1)
        if bash_file_name == '':
            io_manager.print_err_info('Bash file name is empty')
            sys.exit(1)

        os.system('chmod +x ' + bash_file_name)
        io_manager.print_dbg_info('Interactive command: ' + cmd + ' ' + bash_file_name)
        # os.system(cmd + ' ' + bash_file_name)

    def _wait_for_file(self, filename, max_wait_sec=120, check_interval=0.2):
        """
        Wait for file. Return True if file was detected within specified 'max_wait_sec'
        limit
        :param filename: filename on task machine
        :param max_wait_sec: how long to wait in seconds
        :param check_interval: how often to check in seconds
        :return: False if waiting was was cut short by max_wait_sec limit, True otherwise
        """
        start_time = time.time()
        while True:
            if time.time() - start_time > max_wait_sec:
                io_manager.print_dbg_info('Timeout exceeded (' + str(max_wait_sec)
                                          + ' sec) for ' + filename)
                return False
            if not os.path.isfile(filename):
                time.sleep(check_interval)
                continue
            else:
                break
        return True 

    def _extract_job_id(self, filename):
        """
        Extract job id from a file using predefined regex
        :param filename: Name of the file
        :return: Job ID
        """
        self._wait_for_file(filename)
        with open(filename, 'r') as file:
            str = file.read()

        regex = r'Submitted\sbatch\sjob\s*([^\n]+)'
        srch = re.compile(regex, re.MULTILINE)
        job_id = srch.search(str)
        if job_id is None:
            io_manager.print_err_info('Cannot extract job ID. Regex search returned None')
            return None

        return job_id.group(1)

    def _extract_job_state(self, filename):
        """
        Extract job state from a slurm output file using predefined regex
        :param filename: Name of the file
        :return: Job state
        """
        self._wait_for_file(filename)
        with open(filename, 'r') as file:
            str = file.read()

        regex = r'State:\s*([^\s]+)'
        srch = re.compile(regex, re.MULTILINE)
        state = srch.search(str)
        if state is None:
            io_manager.print_err_info('Cannot extract job state. Regex search returned None')
            return None
        
        return state.group(1)
