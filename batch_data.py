import json
import os
from version import *


class BatchFileData:
    modules = []
    script_base_name = None
    exec_name = None
    exec_options = None
    envars = None
    nodes = 1
    ntasks = 1
    cpus = 1
    partition = 'thin'
    time = 1
    launcher = 'srun'

    def read_config(self, thread_range, config_file_name):
        """
        Read JSON config file
        :param batch_data: Object of batch file data
        :param thread_range: Range of threads count
        :param config_file_name: Name of the config file
        """
        f = open(config_file_name)
        data = json.load(f)
        
        self.modules = data['modules']
        self.script_base_name = data['batch_data']['script_base_name']
        self.exec_name = data['batch_data']['executable_name']
        self.exec_options = data['batch_data']['executable_options']
        self.launcher = data['batch_data']['launcher']
        self.nodes = data['batch_data']['nodes']
        self.ntasks = data['batch_data']['ntasks']
        self.time = data['batch_data']['time']

        thread_range = range(
            data['test_setup']['thread_range'][0],
            data['test_setup']['thread_range'][1]
        )
        f.close()


    def dump_text_to_file(selft, filename, text):
        """
        Dump text to file
        :param filename: File name
        :param text: Text to write
        :return: None
        """
        file = open(filename, 'w')
        file.write(text)
        file.close()


    def generate_batch_file(self, name_postfix=''):
        """
        Generate batch script from the provided input
        :return: Name of the batch file
        """
        file_shebang = '#!/bin/bash'
        file_version = '#\n' \
                    '# This batch script was autogenerated by CowBerry v{0}\n' \
                    '#'.format(VERSION)
        file_header = '#SBATCH -N {0}\n' \
                    '#SBATCH -n {1}\n' \
                    '#SBATCH -c {2}\n' \
                    '#SBATCH -p {3}\n' \
                    '#SBATCH -t {4}\n'.format(self.nodes, self.ntasks, 
                                              self.cpus, self.partition,
                                              self.time)

        file_body = ''
        if not self.envars:
            file_body = '# main body is empty\n'
        else:
            for envar, value in self.envars:
                file_body += 'export ' + envar + '=' + str(value) + '\n'

        # 1) check if self.exec_name can be found in the current folder
        # 2) copy self.exec_name to the TMPDIR
        file_body += 'cp ' + self.exec_name + ' ${TMPDIR}\n'
        file_body += 'WRKDIR=${PWD}\n'
        file_body += 'cd ${TMPDIR}\n'

        file_module = 'module purge\n'
        for module in self.modules:
            file_module += 'module load ' + module + '\n'

        file_cmd = self.launcher + ' ' + self.exec_name + ' ' + self.exec_options + '\n'

        file_footer = ''
        if name_postfix != '':
            file_footer = 'cp -r ${TMPDIR} ${WRKDIR}' + name_postfix

        full_text = file_shebang + '\n' \
                    + file_version + '\n' \
                    + file_header + '\n' \
                    + file_module + '\n' \
                    + file_body + '\n' \
                    + file_cmd + '\n' \
                    + file_footer

        print('----------------------------------------')
        print(full_text)
        print('----------------------------------------')

        batch_file_name = self.script_base_name + name_postfix + '.sh'
        self.dump_text_to_file(batch_file_name, full_text)

        return batch_file_name

    def submit(self, filename):
        os.system('sbatch ' + filename)
